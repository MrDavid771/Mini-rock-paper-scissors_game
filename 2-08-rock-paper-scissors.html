<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rock Paper Scissors - With Enhanced Player AI</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 600px;
            margin: 0 auto;
            padding: 20px;
            text-align: center;
        }
        .game-container {
            margin: 20px 0;
        }
        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            background-color: #4CAF50;
            color: white;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #45a049;
        }
        #resetBtn {
            background-color: #f44336;
        }
        #resetBtn:hover {
            background-color: #d32f2f;
        }
        #resultDisplay {
            margin: 20px 0;
            font-size: 18px;
            min-height: 24px;
        }
    </style>
</head>
<body>
    <h1>Rock Paper Scissors</h1>
    
    <div class="game-container">
        <button onclick="playGame('Rock')">Rock</button>
        <button onclick="playGame('Paper')">Paper</button>
        <button onclick="playGame('Scissors')">Scissors</button>
    </div>

    <div id="resultDisplay"></div>
    
    <p id="scoreDisplay">Wins: 0, Losses: 0, Ties: 0</p>
    
    <button id="resetBtn" onclick="resetScore()">Reset Score</button>

    <script>
        // Game constants
        const MOVES = ['Rock', 'Paper', 'Scissors'];
        
        // Game state
        const state = {
            score: {
                wins: 0,
                losses: 0,
                ties: 0
            },
            userHistory: {
                Rock: 0,
                Paper: 0,
                Scissors: 0
            },
            lastMove: {
                user: null,
                computer: null,
                result: ''
            }
        };

        // DOM elements
        const elements = {
            resultDisplay: document.getElementById('resultDisplay'),
            scoreDisplay: document.getElementById('scoreDisplay')
        };

        // Initialize the game
        function init() {
            loadScores();
            updateScoreDisplay();
        }

        /**
         * Main game function that processes a player's move
         * @param {string} playerMove - The player's move (Rock, Paper, or Scissors)
         */
        function playGame(playerMove) {
            try {
                // Validate input
                if (!isValidMove(playerMove)) {
                    throw new Error('Invalid move. Please choose Rock, Paper, or Scissors.');
                }

                // Update user move history
                state.userHistory[playerMove]++;
                state.lastMove.user = playerMove;

                // Get computer's move
                const computerMove = pickComputerMove();
                state.lastMove.computer = computerMove;

                // Determine the result
                const result = determineWinner(playerMove, computerMove);
                state.lastMove.result = result;

                // Update score
                updateScore(result);

                // Save scores to localStorage
                saveScores();

                // Update the UI
                updateDisplay(playerMove, computerMove, result);
                
            } catch (error) {
                console.error('Error in playGame:', error);
                elements.resultDisplay.textContent = `Error: ${error.message}`;
            }
        }

        /**
         * Validates if the move is one of the allowed options
         * @param {string} move - The move to validate
         * @returns {boolean} - True if the move is valid
         */
        function isValidMove(move) {
            return MOVES.includes(move);
        }

        /**
         * Determines the winner of a round
         * @param {string} playerMove - The player's move
         * @param {string} computerMove - The computer's move
         * @returns {string} - The result of the round ('win', 'lose', or 'tie')
         */
        function determineWinner(playerMove, computerMove) {
            if (playerMove === computerMove) return 'tie';
            
            const winConditions = {
                'Rock': 'Scissors',
                'Paper': 'Rock',
                'Scissors': 'Paper'
            };
            
            return winConditions[playerMove] === computerMove ? 'win' : 'lose';
        }

        /**
         * Updates the score based on the game result
         * @param {string} result - The result of the round ('win', 'lose', or 'tie')
         */
        function updateScore(result) {
            if (result === 'win') {
                state.score.wins++;
            } else if (result === 'lose') {
                state.score.losses++;
            } else {
                state.score.ties++;
            }
        }

        /**
         * AI function to determine the computer's move
         * Uses a simple strategy based on the player's move history
         * @returns {string} - The computer's move (Rock, Paper, or Scissors)
         */
        function pickComputerMove() {
            // If no history yet, pick randomly
            if (Object.values(state.userHistory).every(count => count === 0)) {
                return MOVES[Math.floor(Math.random() * MOVES.length)];
            }

            // Find the player's most used move
            const mostUsedMove = getMostUsedUserMove();
            
            // Counter the player's most used move
            const counterMoves = {
                'Rock': 'Paper',     // Paper beats Rock
                'Paper': 'Scissors', // Scissors beats Paper
                'Scissors': 'Rock'   // Rock beats Scissors
            };
            
            // 70% chance to counter, 30% chance to pick randomly
            return Math.random() < 0.7 ? counterMoves[mostUsedMove] : 
                   MOVES[Math.floor(Math.random() * MOVES.length)];
        }

        /**
         * Determines the player's most used move
         * @returns {string} - The move the player has used most frequently
         */
        function getMostUsedUserMove() {
            let maxCount = -1;
            let mostUsedMove = 'Rock';

            Object.entries(state.userHistory).forEach(([move, count]) => {
                if (count > maxCount) {
                    maxCount = count;
                    mostUsedMove = move;
                }
            });

            return mostUsedMove;
        }

        /**
         * Updates the score display in the UI
         */
        function updateScoreDisplay() {
            const { wins, losses, ties } = state.score;
            elements.scoreDisplay.textContent = `Wins: ${wins}, Losses: ${losses}, Ties: ${ties}`;
        }

        /**
         * Updates the result display in the UI
         * @param {string} playerMove - The player's move
         * @param {string} computerMove - The computer's move
         * @param {string} result - The result of the round ('win', 'lose', or 'tie')
         */
        function updateDisplay(playerMove, computerMove, result) {
            const resultText = {
                'win': 'You Win!',
                'lose': 'You Lose!',
                'tie': "It's a Tie!"
            }[result];

            elements.resultDisplay.innerHTML = `
                <p>You chose: <strong>${playerMove}</strong></p>
                <p>Computer chose: <strong>${computerMove}</strong></p>
                <p><strong>${resultText}</strong></p>
            `;
            
            updateScoreDisplay();
        }

        /**
         * Saves the current scores to localStorage
         */
        function saveScores() {
            try {
                localStorage.setItem('rpsScores', JSON.stringify(state.score));
            } catch (error) {
                console.error('Error saving scores:', error);
            }
        }

        /**
         * Loads scores from localStorage
         */
        function loadScores() {
            try {
                const savedScores = localStorage.getItem('rpsScores');
                if (savedScores) {
                    const parsedScores = JSON.parse(savedScores);
                    state.score = { ...state.score, ...parsedScores };
                }
            } catch (error) {
                console.error('Error loading scores:', error);
            }
        }

        /**
         * Resets the game scores and history
         */
        function resetScore() {
            if (!confirm('Are you sure you want to reset the score?')) {
                return;
            }
            
            // Reset scores
            state.score = { wins: 0, losses: 0, ties: 0 };
            state.userHistory = { Rock: 0, Paper: 0, Scissors: 0 };
            state.lastMove = { user: null, computer: null, result: '' };
            
            // Update UI
            updateScoreDisplay();
            elements.resultDisplay.textContent = 'Game reset. Make your move!';
            
            // Clear saved scores
            localStorage.removeItem('rpsScores');
        }

        // Initialize the game when the page loads
        window.onload = init;
    </script>
</body>
</html>
